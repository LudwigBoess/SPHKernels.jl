var documenterSearchIndex = {"docs":
[{"location":"kernels/#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This package supplies a number of kernels frequently used in Smoothed-Particle Hydrodynamics (SPH), as well as functions to evaluate their values and derivatives in 2D and 3D.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"These kernels include the B-splines (Cubic and Quintic) suggested in Monaghan & Lattanzio (1985) and the Wendland functions (WendlandC2, WendlandC4, WendlandC6) and WendlandC8 (Wendland 2009) as suggested in Dehnen & Aly (2012).","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"In this implementation we follow the convention of Dehnen&Aly in using the 'compact kernel support' as a means to define the maximum extent of the kernel. They denote this H in their paper, for convenience (aka for not having to type caps) we use h in the code.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels\nusing CairoMakie\nimport ColorSchemes\n\nfunction get_kernel_values(x, k)            \n\n    W = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        W[i] = 𝒲(k, x[i], 1.0)\n    end\n\n    W\nend\n\nfunction get_kernel_deriv(x, k)            \n\n    dW = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        dW[i] = d𝒲(k, x[i], 1.0)\n    end\n\n    dW\nend\n\n\nfunction get_kernels(dim)\n\n    [ Cubic(dim), Quintic(dim), \n      WendlandC2(dim), WendlandC4(dim), WendlandC6(dim), WendlandC8(dim)\n    ]\n\nend\n\nN_samples = 1_000\nx = LinRange(0, 1, N_samples)\n\ndims = [1, 2, 3]\n\nlabels = [\"Cubic\", \"Quintic\", \n         \"Wendland C2\", \"Wendland C4\", \"Wendland C6\", \"Wendland C8\"]\n\ncolors = [ColorSchemes.BuPu_7[end], ColorSchemes.BuPu_7[end-1], \n          ColorSchemes.PuBuGn_9[end], ColorSchemes.PuBuGn_9[end-1], ColorSchemes.PuBuGn_9[end-2], ColorSchemes.PuBuGn_9[end-3]]\n\nfs    = 25\nscale = 750\nfig   = Figure(resolution = (1.5*scale, 2.1*scale), fontsize=fs)\n\nfor dim = 1:3\n\n    ax_l = Axis(fig[dim+1, 1], xlabel=\"x = r/h\", ylabel=\"W(x)\")\n    ax_r = Axis(fig[dim+1, 2], xlabel=\"x = r/h\", ylabel=\"W'(x)\")\n\n    kernels = get_kernels(dim)\n\n    max_W = 0.0\n\n    for i ∈ 1:length(kernels)\n\n        W = get_kernel_values(x, kernels[i]) \n        lines!(ax_l, x, W, label=labels[i], color=colors[i])\n\n        if maximum(W) > max_W \n            max_W = maximum(W)\n        end\n\n        dW = get_kernel_deriv(x, kernels[i]) \n        lines!(ax_r, x, dW, label=labels[i], color=colors[i])\n\n    end\n\n    text!(ax_l, \"$(dim)D\", position = (0.9, 0.95max_W), \n            align = (:center, :center), textsize =2fs)\n\nend\n\nline_elem = [LineElement(color = colors[i], linestyle = nothing) for i = 1:length(colors)]\nLegend(fig[1, 1:2], line_elem, labels,\n        framevisible = false, \n        orientation = :horizontal,\n        nbanks = 2)\n\nsave(\"kernels.png\", fig); nothing # hide","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"(Image: kernels)","category":"page"},{"location":"kernels/#Defining-Kernels","page":"Kernels","title":"Defining Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"We use multiple dispatch to make to conform to Julia coding standards and make the code more readable.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"To use e.g. a 3D WendlandC6 kernel use","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"k = WendlandC6(3)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This will default to a 3D kernel with a precision defined by the system OS (usually Float64). If you want to use a Float32 kernel you can define the precision as the (optional) first argument","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"k = WendlandC6(Float32, 3)","category":"page"},{"location":"kernels/#Evaluating-Kernels","page":"Kernels","title":"Evaluating Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"To evaluate a kernel you need to use the function","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"kernel_value(k::AbstractSPHKernel, u::Real, h_inv::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"where AbstractSPHKernel is the supertype for an implemented SPH kernel, u = fracxh is the distance to the kernel origin in measures of the compact kernel support and h_inv is the inverse of the compact kernel support.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"You need to define the dimension of the kernel in the kernel <: AbstractSPHKernel, as explained before.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"If you want your code to look a little more fancy you can also use the alternative functions 𝒲.:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"𝒲( kernel::AbstractSPHKernel, u::Real, h_inv::Real) = kernel_value(kernel, u, h_inv)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"As an example:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels # hide\n\n# Wendland C6 kernel with double precision in 3D\nk     = WendlandC6(Float64, 3)\n# distance between the particle and the origin of the kernel\nr     = 0.5\nh     = 1.0\nh_inv = 1.0/h\nu     = r * h_inv\n\n# kernel value at position r\nval = 𝒲(k, u, h_inv)\n\nprintln(\"val = $val\")","category":"page"},{"location":"kernels/#Evaluating-Derivatives","page":"Kernels","title":"Evaluating Derivatives","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"Similar to Evaluating Kernels you can evluate a kernel derivative with","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"kernel_deriv(k::AbstractSPHKernel, u::Real, h_inv::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"or in the fancy way:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"d𝒲(kernel::AbstractSPHKernel, u::Real, h_inv::Real) = kernel_deriv(kernel, u, h_inv)","category":"page"},{"location":"kernels/#Bias-Correction","page":"Kernels","title":"Bias Correction","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"You can correct for the kernel bias of the Wendland kernels as described in Dehnen & Aly (2012), Eq. 18 + 19 with the functions:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"bias_correction(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real, n_neighbours::Integer)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"or again in the fancy way","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"δρ(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real, n_neighbours::Integer) = bias_correction(kernel, density, m, h_inv, n_neighbours)\n","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This will return a new value for the density:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels # hide\ndensity = 1.0\nkernel  = WendlandC6(3)\n\n# correct density\ndensity = bias_correction_3D(kernel, density, 1.0, 0.5, 295)\n\nprintln(\"density = $density\")","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHKernels.AbstractSPHKernel","page":"API reference","title":"SPHKernels.AbstractSPHKernel","text":"AbstractSPHKernel\n\nSupertype for all SPH kernels.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Cubic","page":"API reference","title":"SPHKernels.Cubic","text":"Cubic(T::DataType=Float64, n_neighbours::Integer=64)\n\nSet up a Cubic kernel for a given DataType T and dimensin dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Cubic-Tuple{Integer}","page":"API reference","title":"SPHKernels.Cubic","text":"Cubic(dim::Integer)\n\nDefine Cubic kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.Quintic","page":"API reference","title":"SPHKernels.Quintic","text":"Quintic(T::DataType=Float64, n_neighbours::Integer=64)\n\nSet up a Quintic kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Quintic-Tuple{Integer}","page":"API reference","title":"SPHKernels.Quintic","text":"Quintic(dim::Integer)\n\nDefine Quintic kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC2","page":"API reference","title":"SPHKernels.WendlandC2","text":"WendlandC2(T::DataType=Float64, n_neighbours::Integer=216)\n\nSet up a WendlandC2 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC2-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC2","text":"WendlandC2(dim::Integer)\n\nDefine WendlandC2 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC4","page":"API reference","title":"SPHKernels.WendlandC4","text":"WendlandC4(T::DataType=Float64, n_neighbours::Integer=216)\n\nSet up a WendlandC4 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC4-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC4","text":"WendlandC4(dim::Integer)\n\nDefine WendlandC4 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC6","page":"API reference","title":"SPHKernels.WendlandC6","text":"WendlandC6(T::DataType=Float64, dim::Integer=3)\n\nSet up a WendlandC6 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC6-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC6","text":"WendlandC6(dim::Integer)\n\nDefine WendlandC6 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC8","page":"API reference","title":"SPHKernels.WendlandC8","text":"WendlandC8(T::DataType=Float64, n_neighbours::Integer=395)\n\nSet up a WendlandC8 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC8-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC8","text":"WendlandC8(dim::Integer)\n\nDefine WendlandC8 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Cubic{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Cubic{T}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer )  where T\n\nDoes not do anything for the BSplines. Implemented for stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Quintic{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Quintic{T}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer ) where T\n\nDoes not do anything for the BSplines. Implemented for stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC2{T}, SPHKernels.WendlandC2_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC2_1D{T}, WendlandC2{T}}, \n                 density::Real, m::Real, h_inv::Real,\n                 n_neighbours::Integer ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC4{T}, SPHKernels.WendlandC4_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC4_1D{T}, WendlandC4{T}}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Int64 ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC6{T}, SPHKernels.WendlandC6_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC6_1D{T}, WendlandC6{T}}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC8{T}, SPHKernels.WendlandC8_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction(kernel::WendlandC8, density::Real, m::Real, h_inv::Real)\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.d𝒲-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.d𝒲","text":"d𝒲( kernel::AbstractSPHKernel, u::Real, h_inv::Real)\n\nEvaluate derivative at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_curl-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}","page":"API reference","title":"SPHKernels.kernel_curl","text":"kernel_curl( k::AbstractSPHKernel,       h_inv::Real, \n             xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real},\n             Aᵢ::Vector{<:Real}, Aⱼ::Vector{<:Real} )\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{Cubic{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::Cubic{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the Cubic spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{Quintic{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::Quintic{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the Quintic spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC2_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_1D(kernel::WendlandC2{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC2 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC4_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC4_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC4 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC6_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC6_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC6 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC8_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC8_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC8 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC2{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC2{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC2 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC4{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_2D(kernel::WendlandC4{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC4 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC6{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_2D(kernel::WendlandC6, u::Real, h_inv::Real)\n\nEvaluate the derivative of the WendlandC6 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC8{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_2D(kernel::WendlandC8{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC8 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_div-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}","page":"API reference","title":"SPHKernels.kernel_div","text":"kernel_div( k::AbstractSPHKernel,       h_inv::Real, \n            xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real},\n            Aᵢ::Vector{<:Real}, Aⱼ::Vector{<:Real} )\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_gradient-Tuple{AbstractSPHKernel, Real, Real, Real}","page":"API reference","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Union{Real, Vector{<:Real}}, \n                 xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_gradient-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}}","page":"API reference","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, r::Real, h_inv::Real, \n                 Δx::Vector{<:Real})\n\nComputes the gradient of the kernel k at the distance r along the distance vector Δx of the neighbour j. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_gradient-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}","page":"API reference","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Union{Real, Vector{<:Real}}, \n                 xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Tuple{AbstractSPHKernel, Real, Real, Real}","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value( k::AbstractSPHKernel, h_inv::Real, \n              xᵢ::Real, xⱼ::Real )\n\nComputes the value of the kernel k at the position of the neighbour xⱼ. \n\nW(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Tuple{AbstractSPHKernel, Real, Vector{var\"#s6\"} where var\"#s6\"<:Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value( k::AbstractSPHKernel, h_inv::Real, \n              xᵢ::Union{Real, Vector{<:Real}}, \n              xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the value of the kernel k at the position of the neighbour xⱼ. \n\nW(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{Cubic{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value_1D(kernel::Cubic{T}, u::Real, h_inv::Real) where T\n\nEvaluate cubic spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{Quintic{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::Quintic{T}, u::Real, h_inv::Real) where T\n\nEvaluate quintic spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC2_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC2_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC2 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC4_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC4{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC4 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC6_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC6_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC6 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC8_1D{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC8_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC8 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC2{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC2{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC2 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC4{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"(kernel::WendlandC4{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC4 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC6{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value_2D(kernel::WendlandC6{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC6 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC8{T}, Real, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC8{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC8 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_curl-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real, Real, Real}","page":"API reference","title":"SPHKernels.quantity_curl","text":"quantity_curl( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aⱼ::Vector{<:Real},\n      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j m_j fracvecA_jrho_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_divergence-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real, Real, Real}","page":"API reference","title":"SPHKernels.quantity_divergence","text":"quantity_divergence( k::AbstractSPHKernel, h_inv::Real, \n                      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                      Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n                      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i.\n\ncdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_gradient-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.quantity_gradient","text":"quantity_gradient( k::AbstractSPHKernel, \n                   r::Real,  h_inv::Real, \n                   Δx::Union{Real, Vector{<:Real}},\n                   Aⱼ::Union{Real, Vector{<:Real}},\n                   mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_gradient-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}, Union{Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}, Union{Real, Vector{var\"#s39\"} where var\"#s39\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.quantity_gradient","text":"quantity_gradient( k::AbstractSPHKernel, h_inv::Real, \n                   xᵢ::Union{Real, Vector{<:Real}},   \n                   xⱼ::Union{Real, Vector{<:Real}},\n                   Aⱼ::Union{Real, Vector{<:Real}},\n                   mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.δρ-Tuple{AbstractSPHKernel, Real, Real, Real, Integer}","page":"API reference","title":"SPHKernels.δρ","text":"δρ₁(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real)\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇dot𝒜-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real, Real, Real}","page":"API reference","title":"SPHKernels.∇dot𝒜","text":"∇dotA( k::AbstractSPHKernel, h_inv::Real, \n       xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n       Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n       mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i. Compact notation of quantity_divergence.\n\ncdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇x𝒜-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real, Real, Real}","page":"API reference","title":"SPHKernels.∇x𝒜","text":"∇x𝒜( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j m_j fracrho_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇x𝒲-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}","page":"API reference","title":"SPHKernels.∇x𝒲","text":"∇x𝒲( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aⱼ::Vector{<:Real})\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇̇dot𝒲-Tuple{AbstractSPHKernel, Real, Vector{var\"#s5\"} where var\"#s5\"<:Real, Vector{var\"#s4\"} where var\"#s4\"<:Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}","page":"API reference","title":"SPHKernels.∇̇dot𝒲","text":"∇̇dot𝒲( k::AbstractSPHKernel, h_inv::Real, \n        xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n        Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real})\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A. Compact notation of kernel_div.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒜-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}, Vector{var\"#s5\"} where var\"#s5\"<:Real, Real, Real}","page":"API reference","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, \n     r::Real,  h_inv::Real, \n     Δx::Union{Real, Vector{<:Real}},\n     Aⱼ::Union{Real, Vector{<:Real}},\n     mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒜-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s7\"} where var\"#s7\"<:Real}, Real, Real, Real}","page":"API reference","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, \n     r::Real,  h_inv::Real, \n     Δx::Union{Real, Vector{<:Real}},\n     Aⱼ::Union{Real, Vector{<:Real}},\n     mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒜-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}, Union{Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}, Union{Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, h_inv::Real, \n    xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n    Aⱼ::Vector{<:Real},   \n    mⱼ::Real=1,           ρⱼ::Real=1 )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Compact notation of quantity_gradient.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒲-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}}","page":"API reference","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour j.  Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair. Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒲-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}, Union{Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}}","page":"API reference","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ.  Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒜-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s7\"} where var\"#s7\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.𝒜","text":"𝒜( k::AbstractSPHKernel, \n    r::Real,  h_inv::Real, \n    Aⱼ::Union{Real, Vector{<:Real}},\n    mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(r h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒜-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}, Union{Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}, Union{Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.𝒜","text":"𝒜( k::AbstractSPHKernel, h_inv::Real, \n    xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n    Aⱼ::Vector{<:Real},\n    mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒲-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.𝒲","text":"𝒲( kernel::AbstractSPHKernel, u::Real, h_inv::Real)\n\nEvaluate kernel at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒲-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}}","page":"API reference","title":"SPHKernels.𝒲","text":"𝒜( k::AbstractSPHKernel, h_inv::Real, \n    xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n    Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n    mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i.\n\nSee e.g. Price 2012: vecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHKernels.get_r-Tuple{Real, Real}","page":"API reference","title":"SPHKernels.get_r","text":"get_r(xᵢ::Real, xⱼ::Real)\n\nEukledian distance between xᵢ and xⱼ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.get_r-Tuple{Vector{var\"#s6\"} where var\"#s6\"<:Real, Vector{var\"#s7\"} where var\"#s7\"<:Real}","page":"API reference","title":"SPHKernels.get_r","text":"get_r(xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real})\n\nEukledian distance between xᵢ and xⱼ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_quantity-Tuple{AbstractSPHKernel, Real, Real, Union{Real, Vector{var\"#s7\"} where var\"#s7\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.kernel_quantity","text":"kernel_quantity( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                 Aⱼ::Vector{<:Real},\n                 mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_quantity-Tuple{AbstractSPHKernel, Real, Union{Real, Vector{var\"#s5\"} where var\"#s5\"<:Real}, Union{Real, Vector{var\"#s4\"} where var\"#s4\"<:Real}, Union{Real, Vector{var\"#s3\"} where var\"#s3\"<:Real}, Real, Real}","page":"API reference","title":"SPHKernels.kernel_quantity","text":"kernel_quantity( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                 Aⱼ::Vector{<:Real},\n                 mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"extending/#Adding-Kernels","page":"Extending","title":"Adding Kernels","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"If you need a different kernel function than the ones I implemented you can add them by defining a new kernel struct as a subtype of AbstractSPHKernel","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"using SPHKernels # hide\nstruct MyKernel{T} <: AbstractSPHKernel\n    dim::Int64\n    norm::T\nend\n\n\"\"\"\n    MyKernel(T::DataType=Float64, dim::Integer=3)\n\nSet up a `MyKernel` kernel for a given DataType `T`.\n\"\"\"\nMyKernel(T::DataType=Float64, dim::Integer=3) = MyKernel{T}(dim, T(1))\n\n\n\"\"\"\n    MyKernel(dim::Integer)\n\nDefine `MyKernel` kernel with dimension `dim` for the native `DataType` of the OS.\n\"\"\"\nMyKernel(dim::Integer) = MyKernel{T}(typeof(1.0), dim)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"and defining its value and derivative, e.g.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"function kernel_value(kernel::MyKernel{T}, u::Real, h_inv::Real) where T\n\n    if u < 1\n        n = kernel.norm * h_inv^kernel.dim\n        return 1.0 * n |> T\n    else\n        return 0.0 |> T\n    end\n\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"@inline function kernel_deriv(kernel::MyKernel{T}, u::Real, h_inv::Real) where T\n    return 0.0 |> T\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"so you can run the following code","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"k = MyKernel()\nu = 0.5\nh_inv = 1.0\n\nv = kernel_value(k, u, h_inv)\nprintln(\"MyKernel value: $v\")\n\nd = kernel_derivk, u, h_inv)\nprintln(\"MyKernel derivative: $d\")","category":"page"},{"location":"extending/#Contributing","page":"Extending","title":"Contributing","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"Please feel free to create a pull request if you feel that your kernel could be useful to others! I only ask you to also add unit tests for your kernels in the test/runtests.jl file.","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add https://github.com/LudwigBoess/SPHKernels.jl","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"sph/#SPH-Functions","page":"SPH Functions","title":"SPH Functions","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide some basic functions to compute the gradient, divergence and curl of the kernel with a particle quantity if required.","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"Please note that these functions are not terribly flexible and/or performance optimized, as we believe that this should be done in a seperate SPHLoop.jl package. These functions are more meant as a starting point for a more efficient implementation or code that is not used in performance-relevant applications.","category":"page"},{"location":"sph/#Notation","page":"SPH Functions","title":"Notation","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The derivative of a quantity in gradient, divergence and curl can be reduced to the derivative of the kernel combined with the remaining mathematical operation (see e.g. Price (2012)).","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To provide some helper functions we split this into two functions: ","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"One to calculate only the kernel derivative and use as a gradient for divergence and curl with the particle quantity.","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The other to directly calculate the contribution of particle j to the gradient, divergence and curl of the SPH quantity for particle i.","category":"page"},{"location":"sph/#Quantities","page":"SPH Functions","title":"Quantities","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the contribution of particle j to the SPH quantity A for particle i via (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To do this you can loop over the function","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_quantity","category":"page"},{"location":"sph/#SPHKernels.kernel_quantity","page":"SPH Functions","title":"SPHKernels.kernel_quantity","text":"kernel_quantity( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                 Aⱼ::Vector{<:Real},\n                 mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\nkernel_quantity( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                 Aⱼ::Vector{<:Real},\n                 mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"𝒜","category":"page"},{"location":"sph/#SPHKernels.𝒜","page":"SPH Functions","title":"SPHKernels.𝒜","text":"𝒜( k::AbstractSPHKernel, h_inv::Real, \n    xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n    Aⱼ::Vector{<:Real},\n    mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n𝒜( k::AbstractSPHKernel, \n    r::Real,  h_inv::Real, \n    Aⱼ::Union{Real, Vector{<:Real}},\n    mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(r h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Gradient","page":"SPH Functions","title":"Gradient","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The gradient of a quantity in SPH can be reduced to the gradient of the kernel (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the gradient of the kernel at position x_j  W(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_gradient","category":"page"},{"location":"sph/#SPHKernels.kernel_gradient","page":"SPH Functions","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Union{Real, Vector{<:Real}}, \n                 xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\nkernel_gradient( k::AbstractSPHKernel, r::Real, h_inv::Real, \n                 Δx::Vector{<:Real})\n\nComputes the gradient of the kernel k at the distance r along the distance vector Δx of the neighbour j. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\nkernel_gradient( k::AbstractSPHKernel, h_inv::Real, \n                 xᵢ::Union{Real, Vector{<:Real}}, \n                 xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇𝒲","category":"page"},{"location":"sph/#SPHKernels.∇𝒲","page":"SPH Functions","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ.  Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour j.  Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair. Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i  vecA_i(x)  - sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_gradient","category":"page"},{"location":"sph/#SPHKernels.quantity_gradient","page":"SPH Functions","title":"SPHKernels.quantity_gradient","text":"quantity_gradient( k::AbstractSPHKernel, h_inv::Real, \n                   xᵢ::Union{Real, Vector{<:Real}},   \n                   xⱼ::Union{Real, Vector{<:Real}},\n                   Aⱼ::Union{Real, Vector{<:Real}},\n                   mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\nquantity_gradient( k::AbstractSPHKernel, \n                   r::Real,  h_inv::Real, \n                   Δx::Union{Real, Vector{<:Real}},\n                   Aⱼ::Union{Real, Vector{<:Real}},\n                   mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇𝒜","category":"page"},{"location":"sph/#SPHKernels.∇𝒜","page":"SPH Functions","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, h_inv::Real, \n    xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n    Aⱼ::Vector{<:Real},   \n    mⱼ::Real=1,           ρⱼ::Real=1 )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Compact notation of quantity_gradient.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n∇𝒜( k::AbstractSPHKernel, \n     r::Real,  h_inv::Real, \n     Δx::Union{Real, Vector{<:Real}},\n     Aⱼ::Union{Real, Vector{<:Real}},\n     mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n∇𝒜( k::AbstractSPHKernel, \n     r::Real,  h_inv::Real, \n     Δx::Union{Real, Vector{<:Real}},\n     Aⱼ::Union{Real, Vector{<:Real}},\n     mⱼ::Real, ρⱼ::Real )\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Divergence","page":"SPH Functions","title":"Divergence","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The divergence of a quantity in SPH can be calculated as (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"cdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel-2","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the divergence of the kernel at position x_j by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_div","category":"page"},{"location":"sph/#SPHKernels.kernel_div","page":"SPH Functions","title":"SPHKernels.kernel_div","text":"kernel_div( k::AbstractSPHKernel,       h_inv::Real, \n            xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real},\n            Aᵢ::Vector{<:Real}, Aⱼ::Vector{<:Real} )\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇̇dot𝒲","category":"page"},{"location":"sph/#SPHKernels.∇̇dot𝒲","page":"SPH Functions","title":"SPHKernels.∇̇dot𝒲","text":"∇̇dot𝒲( k::AbstractSPHKernel, h_inv::Real, \n        xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n        Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real})\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A. Compact notation of kernel_div.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity-2","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_divergence","category":"page"},{"location":"sph/#SPHKernels.quantity_divergence","page":"SPH Functions","title":"SPHKernels.quantity_divergence","text":"quantity_divergence( k::AbstractSPHKernel, h_inv::Real, \n                      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n                      Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n                      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i.\n\ncdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇dot𝒜","category":"page"},{"location":"sph/#SPHKernels.∇dot𝒜","page":"SPH Functions","title":"SPHKernels.∇dot𝒜","text":"∇dotA( k::AbstractSPHKernel, h_inv::Real, \n       xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n       Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n       mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i. Compact notation of quantity_divergence.\n\ncdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Curl","page":"SPH Functions","title":"Curl","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The curl of a quantity in SPH can be calculated as (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  - sum_j m_j fracvecA_jrho_j times W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel-3","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the divergence of the kernel at position x_j by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_curl","category":"page"},{"location":"sph/#SPHKernels.kernel_curl","page":"SPH Functions","title":"SPHKernels.kernel_curl","text":"kernel_curl( k::AbstractSPHKernel,       h_inv::Real, \n             xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real},\n             Aᵢ::Vector{<:Real}, Aⱼ::Vector{<:Real} )\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇x𝒲","category":"page"},{"location":"sph/#SPHKernels.∇x𝒲","page":"SPH Functions","title":"SPHKernels.∇x𝒲","text":"∇x𝒲( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aⱼ::Vector{<:Real})\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity-3","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_curl","category":"page"},{"location":"sph/#SPHKernels.quantity_curl","page":"SPH Functions","title":"SPHKernels.quantity_curl","text":"quantity_curl( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aⱼ::Vector{<:Real},\n      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j m_j fracvecA_jrho_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇x𝒜","category":"page"},{"location":"sph/#SPHKernels.∇x𝒜","page":"SPH Functions","title":"SPHKernels.∇x𝒜","text":"∇x𝒜( k::AbstractSPHKernel, h_inv::Real, \n      xᵢ::Vector{<:Real},   xⱼ::Vector{<:Real},\n      Aᵢ::Vector{<:Real},   Aⱼ::Vector{<:Real},\n      mⱼ::Real,             ρⱼ::Real )\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j m_j fracrho_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"#Table-of-contents","page":"Table of Contents","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"install.md\", \n          \"kernels.md\",\n          \"extending.md\", \n          \"api.md\"]\nDepth = 3","category":"page"}]
}
