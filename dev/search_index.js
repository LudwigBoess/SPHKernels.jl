var documenterSearchIndex = {"docs":
[{"location":"kernels/#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This package supplies a number of kernels frequently used in Smoothed-Particle Hydrodynamics (SPH), as well as functions to evaluate their values and derivatives in 1D, 2D and 3D.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"These kernels include the B-splines (Cubic and Quintic) suggested in Monaghan & Lattanzio (1985) and the Wendland functions (WendlandC2, WendlandC4, WendlandC6) and WendlandC8 (Wendland 2009) as suggested in Dehnen & Aly (2012).","category":"page"},{"location":"kernels/#Monaghan-Kernels","page":"Kernels","title":"Monaghan Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels\nusing CairoMakie\nimport ColorSchemes\n\nfunction get_kernel_values(x, k)            \n\n    W = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        W[i] = 𝒲(k, x[i], 1.0)\n    end\n\n    W\nend\n\nfunction get_kernel_deriv(x, k)            \n\n    dW = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        dW[i] = d𝒲(k, x[i], 1.0)\n    end\n\n    dW\nend\n\n\nfunction get_kernels(dim)\n\n    [ Cubic(dim), Quintic(dim)]\n\nend\n\nN_samples = 1_000\nx = LinRange(0, 1, N_samples)\n\ndims = [1, 2, 3]\n\nlabels = [\"Cubic\", \"Quintic\"]\n\ncolors = [ColorSchemes.romaO10[end-i] for i = 1:length(labels)]\n\n\nfs    = 25\nscale = 750\nfig   = Figure(resolution = (1.5*scale, 2.1*scale), fontsize=fs)\n\nfor dim = 1:3\n\n    ax_l = Axis(fig[dim+1, 1], xlabel=\"x = r/h\", ylabel=\"W(x)\")\n    ax_r = Axis(fig[dim+1, 2], xlabel=\"x = r/h\", ylabel=\"W'(x)\")\n\n    kernels = get_kernels(dim)\n\n    max_W = 0.0\n\n    for i ∈ 1:length(kernels)\n\n        W = get_kernel_values(x, kernels[i]) \n        lines!(ax_l, x, W, label=labels[i], color=colors[i], linewidth=5)\n\n        if maximum(W) > max_W \n            max_W = maximum(W)\n        end\n\n        dW = get_kernel_deriv(x, kernels[i]) \n        lines!(ax_r, x, dW, label=labels[i], color=colors[i], linewidth=5)\n\n    end\n\n    text!(ax_l, \"$(dim)D\", position = (0.9, 0.95max_W), \n            align = (:center, :center), fontsize =2fs)\n\nend\n\nline_elem = [LineElement(color = colors[i], linestyle = nothing, linewidth=5) for i = 1:length(labels)]\nLegend(fig[1, 1:2], line_elem, labels,\n        framevisible = false, \n        orientation = :horizontal,\n        nbanks = 2)\n\nsave(\"monaghan_kernels.png\", fig); nothing # hide","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"(Image: kernels)","category":"page"},{"location":"kernels/#Wendland-Kernels","page":"Kernels","title":"Wendland Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels\nusing CairoMakie\nimport ColorSchemes\n\nfunction get_kernel_values(x, k)            \n\n    W = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        W[i] = 𝒲(k, x[i], 1.0)\n    end\n\n    W\nend\n\nfunction get_kernel_deriv(x, k)            \n\n    dW = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        dW[i] = d𝒲(k, x[i], 1.0)\n    end\n\n    dW\nend\n\n\nfunction get_kernels(dim)\n\n    [ WendlandC2(dim), WendlandC4(dim), WendlandC6(dim), WendlandC8(dim) ]\n\nend\n\nN_samples = 1_000\nx = LinRange(0, 1, N_samples)\n\ndims = [1, 2, 3]\n\nlabels = [\"Wendland C2\", \"Wendland C4\", \"Wendland C6\", \"Wendland C8\"]\n\ncolors = [ColorSchemes.romaO10[end-i] for i = 1:length(labels)]\n\nfs    = 25\nscale = 750\nfig   = Figure(resolution = (1.5*scale, 2.1*scale), fontsize=fs)\n\nfor dim = 1:3\n\n    ax_l = Axis(fig[dim+1, 1], xlabel=\"x = r/h\", ylabel=\"W(x)\")\n    ax_r = Axis(fig[dim+1, 2], xlabel=\"x = r/h\", ylabel=\"W'(x)\")\n\n    kernels = get_kernels(dim)\n\n    max_W = 0.0\n\n    for i ∈ 1:length(kernels)\n\n        W = get_kernel_values(x, kernels[i]) \n        lines!(ax_l, x, W, label=labels[i], color=colors[i], linewidth=5)\n\n        if maximum(W) > max_W \n            max_W = maximum(W)\n        end\n\n        dW = get_kernel_deriv(x, kernels[i]) \n        lines!(ax_r, x, dW, label=labels[i], color=colors[i], linewidth=5)\n\n    end\n\n    text!(ax_l, \"$(dim)D\", position = (0.9, 0.95max_W), \n            align = (:center, :center), fontsize =2fs)\n\nend\n\nline_elem = [LineElement(color = colors[i], linestyle = nothing, linewidth=5) for i = 1:length(colors)]\nLegend(fig[1, 1:2], line_elem, labels,\n        framevisible = false, \n        orientation = :horizontal,\n        nbanks = 2)\n\nsave(\"wendland_kernels.png\", fig); nothing # hide","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"(Image: kernels)","category":"page"},{"location":"kernels/#Misc-Kernels","page":"Kernels","title":"Misc Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels\nusing CairoMakie\nimport ColorSchemes\n\nfunction get_kernel_values(x, k)            \n\n    W = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        W[i] = 𝒲(k, x[i], 1.0)\n    end\n\n    W\nend\n\nfunction get_kernel_deriv(x, k)            \n\n    dW = Vector{Float64}(undef, length(x))\n    for i = 1:length(x)\n        dW[i] = d𝒲(k, x[i], 1.0)\n    end\n\n    dW\nend\n\n\nfunction get_kernels(dim)\n\n    [ Tophat(), DoubleCosine(dim)]\n\nend\n\nN_samples = 1_000\nx = LinRange(0, 1, N_samples)\n\ndims = [1, 2, 3]\n\nlabels = [\"TopHat\", \"DoubleCosine\"\n         ]\n\ncolors = [ColorSchemes.romaO10[end-i] for i = 1:length(labels)]\n\n\nfs    = 25\nscale = 750\nfig   = Figure(resolution = (1.5*scale, 2.1*scale), fontsize=fs)\n\nfor dim = 1:3\n\n    ax_l = Axis(fig[dim+1, 1], xlabel=\"x = r/h\", ylabel=\"W(x)\")\n    ax_r = Axis(fig[dim+1, 2], xlabel=\"x = r/h\", ylabel=\"W'(x)\")\n\n    kernels = get_kernels(dim)\n\n    max_W = 0.0\n\n    for i ∈ 1:length(kernels)\n\n        W = get_kernel_values(x, kernels[i]) \n        lines!(ax_l, x, W, label=labels[i], color=colors[i], linewidth=5)\n\n        if maximum(W) > max_W \n            max_W = maximum(W)\n        end\n\n        dW = get_kernel_deriv(x, kernels[i]) \n        lines!(ax_r, x, dW, label=labels[i], color=colors[i], linewidth=5)\n\n    end\n\n    text!(ax_l, \"$(dim)D\", position = (0.9, 0.95max_W), \n            align = (:center, :center), fontsize =2fs)\n\nend\n\nline_elem = [LineElement(color = colors[i], linestyle = nothing, linewidth=5) for i = 1:length(colors)]\nLegend(fig[1, 1:2], line_elem, labels,\n        framevisible = false, \n        orientation = :horizontal,\n        nbanks = 2)\n\nsave(\"misc_kernels.png\", fig); nothing # hide","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"(Image: kernels)","category":"page"},{"location":"kernels/#Defining-Kernels","page":"Kernels","title":"Defining Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"We use multiple dispatch to make to conform to Julia coding standards and make the code more readable.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"To use e.g. a 3D WendlandC6 kernel use","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"k = WendlandC6(3)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This will default to a 3D kernel with a precision defined by the system OS (usually Float64). If you want to use a Float32 kernel you can define the precision as the (optional) first argument","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"k = WendlandC6(Float32, 3)","category":"page"},{"location":"kernels/#Evaluating-Kernels","page":"Kernels","title":"Evaluating Kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"To evaluate a kernel you need to use the function","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"kernel_value(k::AbstractSPHKernel, u::Real, h_inv::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"where AbstractSPHKernel is the supertype for an implemented SPH kernel, u = fracxh is the distance to the kernel origin in measures of the smoothing length and h_inv is the inverse of the smoothing length.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"You need to define the dimension of the kernel in the kernel <: AbstractSPHKernel, as explained before.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"If you want your code to look a little more fancy you can also use the alternative functions 𝒲.:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"𝒲( kernel::AbstractSPHKernel, u::Real, h_inv::Real) = kernel_value(kernel, u, h_inv)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"As an example:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels # hide\n\n# Wendland C6 kernel with double precision in 3D\nk     = WendlandC6(Float64, 3)\n# distance between the particle and the origin of the kernel\nr     = 0.5\nh     = 1.0\nh_inv = 1.0/h\nu     = r * h_inv\n\n# kernel value at position r\nval = 𝒲(k, u, h_inv)\n\nprintln(\"val = $val\")","category":"page"},{"location":"kernels/#Evaluating-Derivatives","page":"Kernels","title":"Evaluating Derivatives","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"Similar to Evaluating Kernels you can evluate a kernel derivative with","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"kernel_deriv(k::AbstractSPHKernel, u::Real, h_inv::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"or in the fancy way:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"d𝒲(kernel::AbstractSPHKernel, u::Real, h_inv::Real) = kernel_deriv(kernel, u, h_inv)","category":"page"},{"location":"kernels/#Non-normalized-kernels","page":"Kernels","title":"Non-normalized kernels","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"In some cases it may be useful to evaluate non-normalized kernels and apply the normalization at a later point. This saves some computing time in e.g. loops.","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"For these cases you can evaluate the same functions as above, just without h_inv:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"# non-normalized kernel value\nkernel_value(kernel::AbstractSPHKernel, u::Real)\n𝒲(kernel::AbstractSPHKernel, u::Real)\n\n# non-normalized kernel derivative\nkernel_deriv(kernel::AbstractSPHKernel, u::Real)\nd𝒲(kernel::AbstractSPHKernel, u::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"To apply the normalisation yourself you can use","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"# kernel values\nkernel_norm(kernel::AbstractSPHKernel, h_inv::Real)\n𝒩(kernel::AbstractSPHKernel, h_inv::Real)\n\n# kernel derivatives\nkernel_deriv_norm(kernel::AbstractSPHKernel, h_inv::Real)\nd𝒩(kernel::AbstractSPHKernel, h_inv::Real)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"such that the following holds","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"# kernel values\nkernel_value(kernel, u, h_inv) == kernel_norm(kernel, h_inv) * kernel_value(kernel, u)\n𝒲(kernel, u, h_inv) == 𝒩(kernel, h_inv) * 𝒲(kernel, u)\n\n# kernel derivatives\nkernel_deriv(kernel, u, h_inv) == kernel_deriv_norm(kernel, h_inv) * kernel_deriv(kernel, u)\nd𝒲(kernel, u, h_inv) == d𝒩(kernel, h_inv) * d𝒲(kernel, u)","category":"page"},{"location":"kernels/#Bias-Correction","page":"Kernels","title":"Bias Correction","text":"","category":"section"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"You can correct for the kernel bias of the Wendland kernels as described in Dehnen & Aly (2012), Eq. 18 + 19 with the functions:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"bias_correction(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real, n_neighbours::Integer)","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"or again in the fancy way","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"δρ(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real, n_neighbours::Integer) = bias_correction(kernel, density, m, h_inv, n_neighbours)\n","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"This will return a new value for the density:","category":"page"},{"location":"kernels/","page":"Kernels","title":"Kernels","text":"using SPHKernels # hide\ndensity = 1.0\nkernel  = WendlandC6(3)\n\n# correct density\ndensity = bias_correction(kernel, density, 1.0, 0.5, 295)\n\nprintln(\"density = $density\")","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Exported-Types","page":"API reference","title":"Exported Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHKernels.AbstractSPHKernel","page":"API reference","title":"SPHKernels.AbstractSPHKernel","text":"AbstractSPHKernel\n\nSupertype for all SPH kernels.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Cubic","page":"API reference","title":"SPHKernels.Cubic","text":"Cubic(T::DataType=Float64, dim::Integer=3)\n\nSet up a Cubic kernel for a given DataType T and dimensin dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Cubic-Tuple{Integer}","page":"API reference","title":"SPHKernels.Cubic","text":"Cubic(dim::Integer)\n\nDefine Cubic kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.DoubleCosine","page":"API reference","title":"SPHKernels.DoubleCosine","text":"DoubleCosine(T::DataType=Float64, dim::Integer=3)\n\nSet up a DoubleCosine kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.DoubleCosine-2","page":"API reference","title":"SPHKernels.DoubleCosine","text":"struct DoubleCosine{T} <: AbstractSPHKernel\n    dim::Int64\n    norm::T\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.DoubleCosine-Tuple{Integer}","page":"API reference","title":"SPHKernels.DoubleCosine","text":"DoubleCosine(dim::Integer)\n\nDefine DoubleCosine kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.Quintic","page":"API reference","title":"SPHKernels.Quintic","text":"Quintic(T::DataType=Float64, dim::Integer=3)\n\nSet up a Quintic kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.Quintic-Tuple{Integer}","page":"API reference","title":"SPHKernels.Quintic","text":"Quintic(dim::Integer)\n\nDefine Quintic kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.Tophat","page":"API reference","title":"SPHKernels.Tophat","text":"Tophat(dim::Integer)\n\nDefine Tophat kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC2","page":"API reference","title":"SPHKernels.WendlandC2","text":"WendlandC2(T::DataType=Float64, dim::Integer=3)\n\nSet up a WendlandC2 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC2-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC2","text":"WendlandC2(dim::Integer)\n\nDefine WendlandC2 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC4","page":"API reference","title":"SPHKernels.WendlandC4","text":"WendlandC4(T::DataType=Float64, dim::Integer=3)\n\nSet up a WendlandC4 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC4-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC4","text":"WendlandC4(dim::Integer)\n\nDefine WendlandC4 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC6","page":"API reference","title":"SPHKernels.WendlandC6","text":"WendlandC6(T::DataType=Float64, dim::Integer=3)\n\nSet up a WendlandC6 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC6-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC6","text":"WendlandC6(dim::Integer)\n\nDefine WendlandC6 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.WendlandC8","page":"API reference","title":"SPHKernels.WendlandC8","text":"WendlandC8(T::DataType=Float64, dim::Integer=3)\n\nSet up a WendlandC8 kernel for a given DataType T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPHKernels.WendlandC8-Tuple{Integer}","page":"API reference","title":"SPHKernels.WendlandC8","text":"WendlandC8(dim::Integer)\n\nDefine WendlandC8 kernel with dimension dim for the native DataType of the OS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-Functions","page":"API reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Cubic{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Cubic{T}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer )  where T\n\nDoes not do anything for the BSplines. Implemented for stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{DoubleCosine{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::DoubleCosine{T}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer )  where T\n\nDoes not do anything for the DoubleCosine. Implemented for stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Quintic{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Quintic{T}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer ) where T\n\nDoes not do anything for the BSplines. Implemented for stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Tophat{T}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction(kernel::Tophat{T},\n                density::Real, m::Real, h_inv::Real,\n                n_neighbours::Integer) where {T}\n\nCorrects the density estimate for the kernel bias. Not implemented for Tophat.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC2{T}, SPHKernels.WendlandC2_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC2_1D{T}, WendlandC2{T}}, \n                 density::Real, m::Real, h_inv::Real,\n                 n_neighbours::Integer ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC4{T}, SPHKernels.WendlandC4_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC4_1D{T}, WendlandC4{T}}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Int64 ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC6{T}, SPHKernels.WendlandC6_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction( kernel::Union{WendlandC6_1D{T}, WendlandC6{T}}, \n                 density::Real, m::Real, h_inv::Real, \n                 n_neighbours::Integer ) where T\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.bias_correction-Union{Tuple{T}, Tuple{Union{WendlandC8{T}, SPHKernels.WendlandC8_1D{T}}, Real, Real, Real, Integer}} where T","page":"API reference","title":"SPHKernels.bias_correction","text":"bias_correction(kernel::WendlandC8, density::Real, m::Real, h_inv::Real)\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.d𝒩-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.d𝒩","text":"d𝒩(kernel::AbstractSPHKernel, h_inv::Real)\n\nCalculate the normalisation factor for the kernel derivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.d𝒲-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.d𝒲","text":"d𝒲(kernel::AbstractSPHKernel, u::Real, h_inv::Real)\n\nEvaluate derivative at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.d𝒲-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.d𝒲","text":"d𝒲(kernel::AbstractSPHKernel, u::Real)\n\nEvaluate derivative at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_curl-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_curl","text":"kernel_curl(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::AbstractSPHKernel, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the kernel at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{Cubic{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::Cubic{T}, u::Real) where T\n\nEvaluate the derivative of the Cubic spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{DoubleCosine{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::DoubleCosine, u::Real)\n\nEvaluate the derivative of the DoubleCosine spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{Quintic{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::Quintic{T}, u::Real) where T\n\nEvaluate the derivative of the Quintic spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC2_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_1D(kernel::WendlandC2{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC2 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC4_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC4_1D{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC4 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC6_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC6_1D{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC6 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{SPHKernels.WendlandC8_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC8_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate the derivative of the WendlandC8 spline at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{Tophat{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_1D(kernel::Tophat{T}, u::Real) where T\n\nEvaluate the derivative of the Tophat spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC2{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC2{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC2 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC4{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC4{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC4 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC6{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv(kernel::WendlandC6, u::Real)\n\nEvaluate the derivative of the WendlandC6 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv-Union{Tuple{T}, Tuple{WendlandC8{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_deriv","text":"kernel_deriv_2D(kernel::WendlandC8{T}, u::Real) where T\n\nEvaluate the derivative of the WendlandC8 spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_deriv_norm-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.kernel_deriv_norm","text":"kernel_deriv_norm(kernel::AbstractSPHKernel, h_inv::Real)\n\nCalculate the normalisation factor for the kernel derivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_div-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_div","text":"kernel_div( k::AbstractSPHKernel, h_inv::T1, \n            xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_gradient-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T1, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, r::T1, h_inv::T1, Δx::T2) where {T1,T2}\n\nComputes the gradient of the kernel k at the distance r along the distance vector Δx of the neighbour j. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_gradient-Union{Tuple{T}, Tuple{AbstractSPHKernel, Real, T, T}} where T","page":"API reference","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, h_inv::Real, xᵢ::T, xⱼ::T ) where T\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_norm-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.kernel_norm","text":"kernel_norm(kernel::AbstractSPHKernel, h_inv::Real) where {T}\n\nCalculate the normalisation factor for the kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_norm-Tuple{SPHKernels.WendlandKernel, Real}","page":"API reference","title":"SPHKernels.kernel_norm","text":"kernel_norm(kernel::WendlandKernel, h_inv::Real) where {T}\n\nCalculate the normalisation factor for the WendlandC2 kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_norm-Union{Tuple{T}, Tuple{Tophat{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_norm","text":"kernel_norm(kernel::Tophat, h_inv::Real) where {T}\n\nCalculate the normalisation factor for the Tophat kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_norm-Union{Tuple{T}, Tuple{Union{SPHKernels.WendlandC2_1D{T}, SPHKernels.WendlandC4_1D{T}, SPHKernels.WendlandC6_1D{T}, SPHKernels.WendlandC8_1D{T}}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_norm","text":"kernel_norm(kernel::WendlandC2_1D{T}, h_inv::Real) where {T}\n\nCalculate the normalisation factor for the WendlandC2 kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_quantity-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T1, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_quantity","text":"kernel_quantity(k::AbstractSPHKernel, r::T1, h_inv::T1, \n                Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_quantity-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, Union{T1, T2}, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_quantity","text":"kernel_quantity(k::AbstractSPHKernel, h_inv::T1, \n                xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Tuple{AbstractSPHKernel, Real, Real, Real}","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value( k::AbstractSPHKernel, h_inv::Real, \n              xᵢ::Real, xⱼ::Real )\n\nComputes the value of the kernel k at the position of the neighbour xⱼ. \n\nW(x_i - x_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::AbstractSPHKernel, u::Real, h_inv::Real) where T\n\nEvaluate the kernel at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value( k::AbstractSPHKernel, h_inv::T1, \n                   xᵢ::T2, xⱼ::T2 ) where {T1,T2}\n\nComputes the value of the kernel k at the position of the neighbour xⱼ. \n\nW(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{Cubic{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value_1D(kernel::Cubic{T}, u::Real) where T\n\nEvaluate cubic spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{DoubleCosine{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::DoubleCosine, u::Real)\n\nEvaluate DoubleCosine spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{Quintic{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::Quintic{T}, u::Real) where T\n\nEvaluate quintic spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC2_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC2_1D{T}, u::Real) where T\n\nEvaluate WendlandC2 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC4_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC4{T}, u::Real) where T\n\nEvaluate WendlandC4 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC6_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC6_1D{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC6 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{SPHKernels.WendlandC8_1D{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC8_1D{T}, u::Real) where T\n\nEvaluate WendlandC8 spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{Tophat{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::Tophat{T}, u::Real) where T\n\nEvaluate Tophat spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC2{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC2{T}, u::Real, h_inv::Real) where T\n\nEvaluate WendlandC2 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC4{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC4{T}, u::Real) where T\n\nEvaluate WendlandC4 spline at position u = fracxh without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC6{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC6{T}, u::Real) where T\n\nEvaluate WendlandC6 spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.kernel_value-Union{Tuple{T}, Tuple{WendlandC8{T}, Real}} where T","page":"API reference","title":"SPHKernels.kernel_value","text":"kernel_value(kernel::WendlandC8{T}, u::Real) where T\n\nEvaluate WendlandC8 spline at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_curl-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.quantity_curl","text":"quantity_curl(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j fracm_jrho_j vecA_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_divergence-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.quantity_divergence","text":"quantity_divergence(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i.\n\ncdotvecA_i(x)  sum_j fracm_jrho_j vecA_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_gradient-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T1, T2, T2, T1, T1}} where {T1<:Real, T2}","page":"API reference","title":"SPHKernels.quantity_gradient","text":"quantity_gradient(k::AbstractSPHKernel,\n                  r::T1, h_inv::T1,\n                  Δx::T2, Aⱼ::T2,\n                  mⱼ::T1, ρⱼ::T1) where {T1<:Real,T2}\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.quantity_gradient-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2, T1, T1}} where {T1<:Real, T2}","page":"API reference","title":"SPHKernels.quantity_gradient","text":"quantity_gradient(k::AbstractSPHKernel, h_inv::T1, \n                  xᵢ::T2, xⱼ::T2, Aⱼ::T2,\n                  mⱼ::T1, ρⱼ::T1 ) where {T1<:Real, T2}\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.δρ-Tuple{AbstractSPHKernel, Real, Real, Real, Integer}","page":"API reference","title":"SPHKernels.δρ","text":"δρ₁(kernel::AbstractSPHKernel, density::Real, m::Real, h_inv::Real)\n\nCorrects the density estimate for the kernel bias. See Dehnen&Aly 2012, eq. 18+19.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇dot𝒜-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.∇dot𝒜","text":"∇dot𝒜(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i. Compact notation of quantity_divergence.\n\ncdotvecA_i(x)  sum_j fracm_jrho_j vecA_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇dot𝒲-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.∇dot𝒲","text":"∇dot𝒲( k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A. Compact notation of kernel_div.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇x𝒜-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.∇x𝒜","text":"∇x𝒜(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j fracm_jrho_j vecA_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇x𝒲-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2, T2}} where {T1, T2}","page":"API reference","title":"SPHKernels.∇x𝒲","text":"∇x𝒲(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒜-Tuple{AbstractSPHKernel, Vararg{Any, 6}}","page":"API reference","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, h_inv, xᵢ, xⱼ, Aⱼ, mⱼ, ρⱼ)\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Compact notation of quantity_gradient.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒲-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T1, T2}} where {T1<:Real, T2}","page":"API reference","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour j.  Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair. Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.∇𝒲-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T2, T2}} where {T1<:Real, T2}","page":"API reference","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2 ) where {T1<:Real,T2}\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ.  Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒜-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, T1, T2, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.𝒜","text":"𝒜(k::AbstractSPHKernel, r::T1,  h_inv::T1, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(r h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒜-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractSPHKernel, T1, Union{T1, T2}, Union{T1, T2}, Union{T1, T2}, T1, T1}} where {T1, T2}","page":"API reference","title":"SPHKernels.𝒜","text":"𝒜(k::AbstractSPHKernel, h_inv::T1, \n  xᵢ::Union{T1, T2}, xⱼ::Union{T1, T2},\n  Aⱼ::Union{T1, T2}, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒩-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.𝒩","text":"𝒩(kernel::AbstractSPHKernel, h_inv::Real)\n\nCalculate the normalisation factor for the kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒲-Tuple{AbstractSPHKernel, Any, Any, Any}","page":"API reference","title":"SPHKernels.𝒲","text":"𝒲( k::AbstractSPHKernel, h_inv, xᵢ, xⱼ)\n\nComputes the value of the kernel k at the position of the neighbour xⱼ. \n\nW(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒲-Tuple{AbstractSPHKernel, Real, Real}","page":"API reference","title":"SPHKernels.𝒲","text":"𝒲( kernel::AbstractSPHKernel, u::Real, h_inv::Real)\n\nEvaluate kernel at position u = fracxh.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.𝒲-Tuple{AbstractSPHKernel, Real}","page":"API reference","title":"SPHKernels.𝒲","text":"𝒲( kernel::AbstractSPHKernel, u::Real)\n\nEvaluate kernel at position u = fracxh, without normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Functions","page":"API reference","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"api/#SPHKernels.get_r-Tuple{Real, Real}","page":"API reference","title":"SPHKernels.get_r","text":"get_r(xᵢ::Real, xⱼ::Real)\n\nEukledian distance between xᵢ and xⱼ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPHKernels.get_r-Tuple{Vector{<:Real}, Vector{<:Real}}","page":"API reference","title":"SPHKernels.get_r","text":"get_r(xᵢ::Vector{<:Real}, xⱼ::Vector{<:Real})\n\nEukledian distance between xᵢ and xⱼ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Types","page":"API reference","title":"Private Types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SPHKernels]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"api/#SPHKernels.WendlandKernel","page":"API reference","title":"SPHKernels.WendlandKernel","text":"WendlandKernel\n\nSupertype for Wendland kernels.\n\n\n\n\n\n","category":"type"},{"location":"extending/#Adding-Kernels","page":"Extending","title":"Adding Kernels","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"If you need a different kernel function than the ones I implemented you can add them by defining a new kernel struct as a subtype of AbstractSPHKernel","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"using SPHKernels # hide\nstruct MyKernel{T} <: AbstractSPHKernel\n    dim::Int64\n    norm::T\nend\n\n\"\"\"\n    MyKernel(T::DataType=Float64, dim::Integer=3)\n\nSet up a `MyKernel` kernel for a given DataType `T`.\n\"\"\"\nMyKernel(T::DataType=Float64, dim::Integer=3) = MyKernel{T}(dim, T(1))\n\n\n\"\"\"\n    MyKernel(dim::Integer)\n\nDefine `MyKernel` kernel with dimension `dim` for the native `DataType` of the OS.\n\"\"\"\nMyKernel(dim::Integer) = MyKernel{T}(typeof(1.0), dim)","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"and defining its value and derivative, e.g.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"function kernel_value(kernel::MyKernel{T}, u::Real, h_inv::Real) where T\n\n    if u < 1\n        n = kernel.norm * h_inv^kernel.dim\n        return 1n |> T\n    else\n        return 0 |> T\n    end\n\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"@inline function kernel_deriv(kernel::MyKernel{T}, u::Real, h_inv::Real) where T\n    return 0 |> T\nend","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"so you can run the following code","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"k = MyKernel()\nu = 0.5\nh_inv = 1.0\n\nv = kernel_value(k, u, h_inv)\nprintln(\"MyKernel value: $v\")\n\nd = kernel_deriv(k, u, h_inv)\nprintln(\"MyKernel derivative: $d\")","category":"page"},{"location":"extending/#Contributing","page":"Extending","title":"Contributing","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"Please feel free to create a pull request if you feel that your kernel could be useful to others! I only ask you to also add unit tests for your kernels in the test/runtests.jl file.","category":"page"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"As usual with Julia you can install the package via the internal package manager","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"julia> ]\npkg> add SPHKernels","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"sph/#SPH-Functions","page":"SPH Functions","title":"SPH Functions","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide some basic functions to compute the gradient, divergence and curl of the kernel with a particle quantity if required.","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"Please note that these functions are not terribly flexible and/or performance optimized, as we believe that this should be done in a seperate SPHLoop.jl package. These functions are more meant as a starting point for a more efficient implementation or code that is not used in performance-relevant applications.","category":"page"},{"location":"sph/#Notation","page":"SPH Functions","title":"Notation","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The derivative of a quantity in gradient, divergence and curl can be reduced to the derivative of the kernel combined with the remaining mathematical operation (see e.g. Price (2012)).","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To provide some helper functions we split this into two functions: ","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"One to calculate only the kernel derivative and use as a gradient for divergence and curl with the particle quantity.","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The other to directly calculate the contribution of particle j to the gradient, divergence and curl of the SPH quantity for particle i.","category":"page"},{"location":"sph/#Quantities","page":"SPH Functions","title":"Quantities","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the contribution of particle j to the SPH quantity A for particle i via (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To do this you can loop over the function","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_quantity","category":"page"},{"location":"sph/#SPHKernels.kernel_quantity","page":"SPH Functions","title":"SPHKernels.kernel_quantity","text":"kernel_quantity(k::AbstractSPHKernel, r::T1, h_inv::T1, \n                Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\nkernel_quantity(k::AbstractSPHKernel, h_inv::T1, \n                xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"𝒜","category":"page"},{"location":"sph/#SPHKernels.𝒜","page":"SPH Functions","title":"SPHKernels.𝒜","text":"𝒜(k::AbstractSPHKernel, h_inv::T1, \n  xᵢ::Union{T1, T2}, xⱼ::Union{T1, T2},\n  Aⱼ::Union{T1, T2}, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)\n\n\n\n\n\n𝒜(k::AbstractSPHKernel, r::T1,  h_inv::T1, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the SPH quantity A for particle i. Based on Euclidean distance r between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j m_j fracvecA_jrho_j W(r h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Gradient","page":"SPH Functions","title":"Gradient","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The gradient of a quantity in SPH can be reduced to the gradient of the kernel (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the gradient of the kernel at position x_j  W(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_gradient","category":"page"},{"location":"sph/#SPHKernels.kernel_gradient","page":"SPH Functions","title":"SPHKernels.kernel_gradient","text":"kernel_gradient( k::AbstractSPHKernel, h_inv::Real, xᵢ::T, xⱼ::T ) where T\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\nkernel_gradient( k::AbstractSPHKernel, r::T1, h_inv::T1, Δx::T2) where {T1,T2}\n\nComputes the gradient of the kernel k at the distance r along the distance vector Δx of the neighbour j. \n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇𝒲","category":"page"},{"location":"sph/#SPHKernels.∇𝒲","page":"SPH Functions","title":"SPHKernels.∇𝒲","text":"∇𝒲( k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2 ) where {T1<:Real,T2}\n\nComputes the gradient of the kernel k at the position of the neighbour xⱼ.  Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n∇𝒲( k::AbstractSPHKernel, h_inv::Real, xᵢ::Union{Real, Vector{<:Real}}, xⱼ::Union{Real, Vector{<:Real}} )\n\nComputes the gradient of the kernel k at the position of the neighbour j.  Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair. Compact notation of kernel_gradient.\n\nW(x_ij h_i) = fracdWdxvert_x_j fracΔx_ijx_ij frac1h_i \n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i  vecA_i(x)  - sum_j m_j fracvecA_jrho_j W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_gradient","category":"page"},{"location":"sph/#SPHKernels.quantity_gradient","page":"SPH Functions","title":"SPHKernels.quantity_gradient","text":"quantity_gradient(k::AbstractSPHKernel, h_inv::T1, \n                  xᵢ::T2, xⱼ::T2, Aⱼ::T2,\n                  mⱼ::T1, ρⱼ::T1 ) where {T1<:Real, T2}\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on positions xᵢ and xⱼ.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\nquantity_gradient(k::AbstractSPHKernel,\n                  r::T1, h_inv::T1,\n                  Δx::T2, Aⱼ::T2,\n                  mⱼ::T1, ρⱼ::T1) where {T1<:Real,T2}\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Based on Euclidean distance r and distance vector Δx between the particles.  Useful if many quantities need to be computed for the same particle pair.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇𝒜","category":"page"},{"location":"sph/#SPHKernels.∇𝒜","page":"SPH Functions","title":"SPHKernels.∇𝒜","text":"∇𝒜( k::AbstractSPHKernel, h_inv, xᵢ, xⱼ, Aⱼ, mⱼ, ρⱼ)\n\nCompute the contribution of particle j to the gradient of the SPH quantity A for particle i. Compact notation of quantity_gradient.\n\nvecA_i(x)  sum_j fracm_jrho_j vecA_j  W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Divergence","page":"SPH Functions","title":"Divergence","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The divergence of a quantity in SPH can be calculated as (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"cdotvecA_i(x)  sum_j m_j fracvecA_jrho_j cdot W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel-2","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the divergence of the kernel at position x_j by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_div","category":"page"},{"location":"sph/#SPHKernels.kernel_div","page":"SPH Functions","title":"SPHKernels.kernel_div","text":"kernel_div( k::AbstractSPHKernel, h_inv::T1, \n            xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇dot𝒲","category":"page"},{"location":"sph/#SPHKernels.∇dot𝒲","page":"SPH Functions","title":"SPHKernels.∇dot𝒲","text":"∇dot𝒲( k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel divergence ∇⋅𝒲 between particle i and neighbour j for some SPH quantity A. Compact notation of kernel_div.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity-2","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_divergence","category":"page"},{"location":"sph/#SPHKernels.quantity_divergence","page":"SPH Functions","title":"SPHKernels.quantity_divergence","text":"quantity_divergence(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i.\n\ncdotvecA_i(x)  sum_j fracm_jrho_j vecA_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇dot𝒜","category":"page"},{"location":"sph/#SPHKernels.∇dot𝒜","page":"SPH Functions","title":"SPHKernels.∇dot𝒜","text":"∇dot𝒜(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the divergence of the SPH quantity A for particle i. Compact notation of quantity_divergence.\n\ncdotvecA_i(x)  sum_j fracm_jrho_j vecA_j cdot W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/#Curl","page":"SPH Functions","title":"Curl","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"The curl of a quantity in SPH can be calculated as (see e.g. Price 2012):","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"vecA_i(x)  - sum_j m_j fracvecA_jrho_j times W(vecx_i - vecx_j h_i)","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"We provide two functionalities ","category":"page"},{"location":"sph/#Kernel-3","page":"SPH Functions","title":"Kernel","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"You can compute the divergence of the kernel at position x_j by using","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"kernel_curl","category":"page"},{"location":"sph/#SPHKernels.kernel_curl","page":"SPH Functions","title":"SPHKernels.kernel_curl","text":"kernel_curl(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its more compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇x𝒲","category":"page"},{"location":"sph/#SPHKernels.∇x𝒲","page":"SPH Functions","title":"SPHKernels.∇x𝒲","text":"∇x𝒲(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2) where {T1,T2}\n\nCompute the kernel curl ∇x𝒲 between particle i and neighbour j for some SPH quantity A.\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"where xᵢ and xⱼ are the positions of particles i and j in 1D-3D space.","category":"page"},{"location":"sph/#Quantity-3","page":"SPH Functions","title":"Quantity","text":"","category":"section"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"To compute the gradient of a SPH quantity for particle i you can loop over","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"quantity_curl","category":"page"},{"location":"sph/#SPHKernels.quantity_curl","page":"SPH Functions","title":"SPHKernels.quantity_curl","text":"quantity_curl(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j fracm_jrho_j vecA_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"or its compact form","category":"page"},{"location":"sph/","page":"SPH Functions","title":"SPH Functions","text":"∇x𝒜","category":"page"},{"location":"sph/#SPHKernels.∇x𝒜","page":"SPH Functions","title":"SPHKernels.∇x𝒜","text":"∇x𝒜(k::AbstractSPHKernel, h_inv::T1, xᵢ::T2, xⱼ::T2, Aⱼ::T2, mⱼ::T1, ρⱼ::T1 ) where {T1,T2}\n\nCompute the contribution of particle j to the curl of the SPH quantity A for particle i.\n\nvecA_i(x)  - sum_j fracm_jrho_j vecA_j times W(vecx_i - vecx_j h_i)\n\n\n\n\n\n","category":"function"},{"location":"#SPHKernels.jl","page":"Table of Contents","title":"SPHKernels.jl","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"This package supplies a number of kernels frequently used in Smoothed-Particle Hydrodynamics (SPH), as well as functions to evaluate their values and derivatives in 2D and 3D.","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"The implementation closely follows the one in Gadget2, see Springel (2005) for details.","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"These kernels include the B-splines (Cubic and Quintic) suggested in Monaghan & Lattanzio (1985), the Wendland functions (WendlandC2, WendlandC4 and WendlandC6 from Wendland (2009)) as suggested in Dehnen & Aly (2012) and WendlandC8 as suggested by Kummer et. al. (2019).","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":":warning: The version numbering of this package is unfortunately not really reflective of the state. I made an error on the original setup of the repository, so I had to start out with version 1.0. View this more as v0.2, instead of v2.0!: Please sanity-check everything before you use it in production!","category":"page"},{"location":"#Table-of-contents","page":"Table of Contents","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"CurrentModule = SPHKernels\nDocTestSetup = quote\n    using SPHKernels\nend","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [ \"index.md\", \n          \"install.md\", \n          \"kernels.md\",\n          \"extending.md\", \n          \"api.md\"]\nDepth = 3","category":"page"}]
}
